"use strict";(globalThis.webpackChunktmp_docusaurus_project=globalThis.webpackChunktmp_docusaurus_project||[]).push([[5658],{8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}},9067:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1/chapter-2","title":"Chapter 2: ROS 2 Fundamentals: Nodes, Topics, and Services","description":"\ud83c\udfaf Learning Objectives","source":"@site/docs/module-1/chapter-2.md","sourceDirName":"module-1","slug":"/module-1/chapter-2","permalink":"/docs/module-1/chapter-2","draft":false,"unlisted":false,"editUrl":"https://github.com/EngineerAbdullahIqbal/roboailearner/tree/main/robotics_book_content/docs/module-1/chapter-2.md","tags":[],"version":"current","frontMatter":{"id":"chapter-2","title":"Chapter 2: ROS 2 Fundamentals: Nodes, Topics, and Services","difficulty_level":"Intermediate","hardware_required":"NVIDIA Jetson Orin Nano (optional for advanced labs), Ubuntu 22.04 with ROS 2 Humble"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Introduction to Physical AI and Embodied Intelligence","permalink":"/docs/module-1/chapter-1"},"next":{"title":"Chapter 3: ROS 2 Tools: Rviz, Gazebo, and the CLI","permalink":"/docs/module-1/chapter-3"}}');var r=i(4848),t=i(8453);const o={id:"chapter-2",title:"Chapter 2: ROS 2 Fundamentals: Nodes, Topics, and Services",difficulty_level:"Intermediate",hardware_required:"NVIDIA Jetson Orin Nano (optional for advanced labs), Ubuntu 22.04 with ROS 2 Humble"},a="Chapter 2: ROS 2 Fundamentals: Nodes, Topics, and Services",l={},c=[{value:"\ud83c\udfaf Learning Objectives",id:"-learning-objectives",level:3},{value:"\ud83e\udde0 Theory: ROS 2 Nodes",id:"-theory-ros-2-nodes",level:3},{value:"Life Cycle of a Node",id:"life-cycle-of-a-node",level:4},{value:"\ud83d\udcbb Implementation: Creating a Simple Node",id:"-implementation-creating-a-simple-node",level:3},{value:"Node Communication and Graph Structure",id:"node-communication-and-graph-structure",level:4},{value:"\ud83e\udde0 Theory: ROS 2 Topics",id:"-theory-ros-2-topics",level:3},{value:"Quality of Service (QoS)",id:"quality-of-service-qos",level:4},{value:"Real-world QoS implications",id:"real-world-qos-implications",level:4},{value:"\ud83d\udee0\ufe0f Architecture",id:"\ufe0f-architecture",level:3},{value:"\ud83d\udcbb Implementation",id:"-implementation",level:3},{value:"Minimal Publisher (<code>minimal_publisher.py</code>)",id:"minimal-publisher-minimal_publisherpy",level:4},{value:"Minimal Subscriber (<code>minimal_subscriber.py</code>)",id:"minimal-subscriber-minimal_subscriberpy",level:4},{value:"\u26a0\ufe0f Common Pitfalls (Sim vs. Real)",id:"\ufe0f-common-pitfalls-sim-vs-real",level:3},{value:"\ud83e\uddea Verification",id:"-verification",level:3},{value:"\ud83e\udde0 Theory: ROS 2 Services",id:"-theory-ros-2-services",level:3},{value:"\ud83d\udee0\ufe0f Architecture",id:"\ufe0f-architecture-1",level:3},{value:"\ud83d\udcbb Implementation",id:"-implementation-1",level:3},{value:"<code>package.xml</code> modification (inside <code>&lt;my_robot_pkg&gt;/package.xml</code>)",id:"packagexml-modification-inside-my_robot_pkgpackagexml",level:4},{value:"<code>setup.py</code> modification (inside <code>&lt;my_robot_pkg&gt;/setup.py</code>)",id:"setuppy-modification-inside-my_robot_pkgsetuppy",level:4},{value:"Add Two Ints Server (<code>add_two_ints_server.py</code>)",id:"add-two-ints-server-add_two_ints_serverpy",level:4},{value:"Add Two Ints Client (<code>add_two_ints_client.py</code>)",id:"add-two-ints-client-add_two_ints_clientpy",level:4},{value:"\u26a0\ufe0f Common Pitfalls (Sim vs. Real)",id:"\ufe0f-common-pitfalls-sim-vs-real-1",level:3},{value:"\ud83e\uddea Verification",id:"-verification-1",level:3},{value:"\ud83d\udcdd Chapter Summary",id:"-chapter-summary",level:3},{value:"\ud83d\udd1a Conclusion",id:"-conclusion",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:":::translate:::en"}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-2-ros-2-fundamentals-nodes-topics-and-services",children:"Chapter 2: ROS 2 Fundamentals: Nodes, Topics, and Services"})}),"\n",(0,r.jsx)(n.h3,{id:"-learning-objectives",children:"\ud83c\udfaf Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"Upon completing this chapter, students will be able to:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Understand ROS 2 Core Concepts"}),": Define and explain the purpose of ROS 2 nodes, topics, and services as fundamental communication primitives."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement ROS 2 Nodes"}),": Create, compile, and run basic ROS 2 Python nodes for simple functionalities."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Master Topic-Based Communication"}),": Implement publisher and subscriber nodes, demonstrating asynchronous data flow using ROS 2 topics."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Apply Quality of Service (QoS) Settings"}),": Select and configure appropriate QoS profiles (Reliability, History, Depth) for different data types (e.g., sensor data vs. control commands) in real-world robotics scenarios."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Utilize Service-Based Communication"}),": Develop service server and client nodes to enable synchronous request-response interactions for specific robot tasks."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'In this chapter, we delve into the foundational communication mechanisms of ROS 2: Nodes, Topics, and Services. These concepts are the bedrock upon which all complex robotic applications are built, enabling a distributed and modular approach to robot control and perception. You will learn how individual computational units (Nodes) communicate data (Topics) and request actions (Services), forming the intricate "nervous system" of a robot. We will explore practical Python implementations, focusing on how Quality of Service (QoS) settings are crucial for ensuring safe, reliable, and high-performance operation on real physical hardware, bridging the gap between theoretical understanding and practical deployment. By the end, you\'ll have a solid grasp of how to orchestrate these components to build robust and responsive robotic systems.'}),"\n",(0,r.jsx)(n.h3,{id:"-theory-ros-2-nodes",children:"\ud83e\udde0 Theory: ROS 2 Nodes"}),"\n",(0,r.jsxs)(n.p,{children:[":::translate:::\nIn ROS 2, a ",(0,r.jsx)(n.strong,{children:"Node"})," is the fundamental unit of computation. It is a process that performs a specific task. A complex robot like a Unitree G1 isn't controlled by one giant script; it's controlled by dozens (or hundreds) of small, modular nodes working in parallel."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Modularity"}),": One node might handle the camera driver, another processes images for obstacles, and a third calculates motor commands. If the camera driver crashes, the motor controller keeps running, ensuring safety."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Discovery"}),": ROS 2 uses a distributed discovery mechanism (DDS - Data Distribution Service). Nodes automatically find each other on the network without a central master (unlike ROS 1), making the system more robust and flexible for multi-robot fleets."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"life-cycle-of-a-node",children:"Life Cycle of a Node"}),"\n",(0,r.jsxs)(n.p,{children:["A managed node (Lifecycle Node) has specific states: ",(0,r.jsx)(n.code,{children:"Unconfigured"}),", ",(0,r.jsx)(n.code,{children:"Inactive"}),", ",(0,r.jsx)(n.code,{children:"Active"}),", and ",(0,r.jsx)(n.code,{children:"Finalized"}),'. This is vital for physical hardware. You don\'t want your motor controller to be "Active" and sending current before the safety checks have been configured.']}),"\n",(0,r.jsx)(n.h3,{id:"-implementation-creating-a-simple-node",children:"\ud83d\udcbb Implementation: Creating a Simple Node"}),"\n",(0,r.jsx)(n.p,{children:"We'll create a basic Python node."}),"\n",(0,r.jsx)(n.h4,{id:"node-communication-and-graph-structure",children:"Node Communication and Graph Structure"}),"\n",(0,r.jsxs)(n.p,{children:["ROS 2 nodes typically form a graph where nodes communicate with each other through topics, services, and actions. This graph represents the entire computational architecture of the robot. Tools like ",(0,r.jsx)(n.code,{children:"rqt_graph"})," allow developers to visualize this dynamic graph, which is invaluable for debugging and understanding the data flow within a complex robotic system. Each node operates independently, reducing system coupling and increasing robustness. If one sensor driver node fails, other parts of the robot\u2019s control system can often continue operating, perhaps with degraded performance, rather than causing a complete system shutdown. This modularity is a cornerstone of scalable and fault-tolerant robotic software."]}),"\n",(0,r.jsx)(n.p,{children:"Context: This file would typically live at /home/abdullahiqbal/Abdullah/hackathon-book-project/src/my_robot_pkg/my_robot_pkg/my_first_node.py"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass MyFirstNode(Node):\n    def __init__(self):\n        # Initialize the node with the name 'my_first_node'\n        super().__init__('my_first_node')\n        self.get_logger().info('Hello from ROS 2!')\n\n        # Create a timer that calls 'timer_callback' every 1.0 seconds\n        self.create_timer(1.0, self.timer_callback)\n        self.counter = 0\n\n    def timer_callback(self):\n        self.get_logger().info(f'Counter: {self.counter}')\n        self.counter += 1\n\ndef main(args=None):\n    # Initialize the ROS 2 Python client library\n    rclpy.init(args=args)\n\n    # Create the node\n    node = MyFirstNode()\n\n    # Spin the node so it can process callbacks (blocking)\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n\n    # Cleanup\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To run this, you would typically add an entry point to your ",(0,r.jsx)(n.code,{children:"setup.py"})," and use ",(0,r.jsx)(n.code,{children:"ros2 run"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# First, ensure your ROS 2 environment is sourced\n# This step is critical for ROS 2 commands to be found\nsource /opt/ros/humble/setup.bash\n# If you are in a colcon workspace, also source your workspace setup\n# source /path/to/your/workspace/install/setup.bash\n\n# Build your package (assuming you have a workspace setup)\ncolcon build --packages-select my_robot_pkg\n\n# Source your workspace again after building to include the new executable\nsource install/setup.bash\n\n# Then, run the node in a terminal\nros2 run my_robot_pkg my_first_node\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In a ",(0,r.jsx)(n.strong,{children:"separate terminal"}),", you can list all active ROS 2 nodes:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 node list\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You should see ",(0,r.jsx)(n.code,{children:"/my_first_node"})," in the output, confirming it's running."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-theory-ros-2-topics",children:"\ud83e\udde0 Theory: ROS 2 Topics"}),"\n",(0,r.jsxs)(n.p,{children:[":::translate:::\n",(0,r.jsx)(n.strong,{children:"Topics"})," are the primary mechanism for asynchronous, many-to-many communication in ROS 2. They operate on a publish-subscribe model, where nodes publish data to a named topic, and other nodes subscribe to that topic to receive the data. This decoupled communication allows for flexible and scalable robotic architectures."]}),"\n",(0,r.jsxs)(n.p,{children:["Imagine a robot's perception system. A ",(0,r.jsx)(n.code,{children:"CameraNode"})," might publish raw image data to a topic ",(0,r.jsx)(n.code,{children:"/camera/image_raw"}),". An ",(0,r.jsx)(n.code,{children:"ObjectDetectionNode"})," subscribes to this topic, processes the images, and publishes bounding box detections to ",(0,r.jsx)(n.code,{children:"/perception/objects"}),". Finally, a ",(0,r.jsx)(n.code,{children:"NavigationNode"})," subscribes to ",(0,r.jsx)(n.code,{children:"/perception/objects"})," to plan its path, avoiding obstacles. Each node focuses on its specific task without needing direct knowledge of other nodes' internal workings."]}),"\n",(0,r.jsx)(n.h4,{id:"quality-of-service-qos",children:"Quality of Service (QoS)"}),"\n",(0,r.jsx)(n.p,{children:"QoS is not just a software abstraction; it dictates how critical data moves between physical components. For embodied intelligence, QoS settings are paramount to safety and performance. When you move atoms, precision and timing are survival."}),"\n",(0,r.jsx)(n.p,{children:"The most important QoS settings for robotics are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reliability"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Reliable"}),": Guarantees that every message will be delivered, even if it means retransmitting lost packets. ",(0,r.jsxs)(n.strong,{children:["Use for control commands (e.g., ",(0,r.jsx)(n.code,{children:"/cmd_vel"}),") where missing a message could cause unsafe robot behavior."]})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Best Effort"}),": Attempts to deliver messages, but does not guarantee delivery. Lost messages are not retransmitted. ",(0,r.jsxs)(n.strong,{children:["Use for high-bandwidth sensor data (e.g., ",(0,r.jsx)(n.code,{children:"/camera/image_raw"}),", ",(0,r.jsx)(n.code,{children:"/scan"}),") where getting the latest data quickly is more important than receiving every single frame."]})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Durability"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Transient Local"}),": New subscribers will receive the last message published immediately upon connecting. Useful for static configuration data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Volatile"}),": Only receives messages published ",(0,r.jsx)(n.em,{children:"after"})," the subscription is established. Standard for most real-time data."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"History"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Keep Last (N)"}),": Keeps the last N messages in the queue."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Keep All"}),": Keeps all messages up to the queue depth."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Depth"}),": The size of the message queue. A deeper queue can buffer more messages but increases potential latency."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"real-world-qos-implications",children:"Real-world QoS implications"}),"\n",(0,r.jsxs)(n.p,{children:["Consider a robot navigating a cluttered environment. Its LiDAR sensor might publish scan data at 10 Hz to the ",(0,r.jsx)(n.code,{children:"/scan"})," topic. If the ",(0,r.jsx)(n.code,{children:"reliability"})," is set to ",(0,r.jsx)(n.code,{children:"Reliable"})," for this high-bandwidth data, and network conditions are poor, the system might spend too much time retransmitting lost packets, leading to increased latency and outdated map information. Conversely, setting the ",(0,r.jsx)(n.code,{children:"reliability"})," to ",(0,r.jsx)(n.code,{children:"Best Effort"})," would prioritize the delivery of the ",(0,r.jsx)(n.em,{children:"latest"})," scan, allowing the navigation system to react to the current environment rather than a stale representation. However, for a motor command to ",(0,r.jsx)(n.code,{children:"/cmd_vel"}),", ",(0,r.jsx)(n.code,{children:"Reliable"})," is paramount. A lost stop command could lead to a collision. Similarly, ",(0,r.jsx)(n.code,{children:"Durability"})," can be critical; a new subscriber to a static configuration topic might need to immediately receive the last published configuration (Transient Local) rather than waiting for the next update (Volatile). The ",(0,r.jsx)(n.code,{children:"History"})," and ",(0,r.jsx)(n.code,{children:"Depth"})," settings further refine this by controlling how many past messages are kept in the queue, balancing memory usage, latency, and data integrity."]}),"\n",(0,r.jsx)(n.h3,{id:"\ufe0f-architecture",children:"\ud83d\udee0\ufe0f Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Two nodes communicating via a topic."}),"\n",(0,r.jsx)(n.mermaid,{value:"graph LR\n    A[CameraNode] --\x3e|/camera/image_raw| B[ObjectDetectionNode]"}),"\n",(0,r.jsx)(n.h3,{id:"-implementation",children:"\ud83d\udcbb Implementation"}),"\n",(0,r.jsxs)(n.p,{children:["Here, we create a simple publisher and subscriber pair. The ",(0,r.jsx)(n.code,{children:"MinimalPublisher"})," node publishes ",(0,r.jsx)(n.code,{children:"String"})," messages, and the ",(0,r.jsx)(n.code,{children:"MinimalSubscriber"})," node receives them. Pay close attention to the QoS profile definition, as this is critical for real-world robotics."]}),"\n",(0,r.jsx)(n.p,{children:"Context: These files would typically live at:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"/home/abdullahiqbal/Abdullah/hackathon-book-project/src/my_robot_pkg/my_robot_pkg/minimal_publisher.py"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"/home/abdullahiqbal/Abdullah/hackathon-book-project/src/my_robot_pkg/my_robot_pkg/minimal_subscriber.py"})}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"minimal-publisher-minimal_publisherpy",children:["Minimal Publisher (",(0,r.jsx)(n.code,{children:"minimal_publisher.py"}),")"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy\n\nfrom std_msgs.msg import String # Standard ROS 2 String message type\n\nclass MinimalPublisher(Node):\n    \"\"\"\n    A ROS 2 Node that publishes String messages to the 'topic' topic.\n    Demonstrates QoS settings for a publisher.\n    \"\"\"\n    def __init__(self):\n        super().__init__('minimal_publisher')\n\n        # Define a QoS profile for sensor data (Best Effort, keep last 1)\n        # This is suitable for high-frequency data where missing an occasional message is acceptable\n        # but getting the latest data quickly is paramount.\n        sensor_qos_profile = QoSProfile(\n            reliability=ReliabilityPolicy.BEST_EFFORT, # Prioritize speed over guaranteed delivery\n            history=HistoryPolicy.KEEP_LAST,\n            depth=1, # Only keep the latest message\n            durability=DurabilityPolicy.VOLATILE # Only send to active subscribers\n        )\n\n        # Create a publisher that will publish String messages to the 'topic' topic\n        # We use the sensor_qos_profile here, assuming this might be like a simple sensor stream\n        self.publisher_ = self.create_publisher(String, 'topic', sensor_qos_profile)\n\n        self.i = 0\n        # Create a timer that calls 'timer_callback' method every 0.5 seconds\n        self.timer = self.create_timer(0.5, self.timer_callback)\n        self.get_logger().info(f'MinimalPublisher started with QoS: Reliability={sensor_qos_profile.reliability.name}, Depth={sensor_qos_profile.depth}')\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello World: {self.i}'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MinimalPublisher()\n    try:\n        rclpy.spin(node) # Keep the node alive\n    except KeyboardInterrupt:\n        node.get_logger().info('Publisher node stopped cleanly.')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n# To make this node executable, add to setup.py:\n# entry_points={\n#     'console_scripts': [\n#         'minimal_publisher = my_robot_pkg.minimal_publisher:main',\n#     ],\n# },\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"minimal-subscriber-minimal_subscriberpy",children:["Minimal Subscriber (",(0,r.jsx)(n.code,{children:"minimal_subscriber.py"}),")"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy\n\nfrom std_msgs.msg import String # Standard ROS 2 String message type\n\nclass MinimalSubscriber(Node):\n    \"\"\"\n    A ROS 2 Node that subscribes to String messages from the 'topic' topic.\n    Demonstrates QoS settings for a subscriber.\n    \"\"\"\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n\n        # Define a QoS profile for command data (Reliable, keep last 1)\n        # This is suitable for control commands where every message MUST be received\n        # and latency is still important (hence depth=1 for the latest command).\n        command_qos_profile = QoSProfile(\n            reliability=ReliabilityPolicy.RELIABLE, # Guarantee delivery\n            history=HistoryPolicy.KEEP_LAST,\n            depth=1, # Only care about the latest command\n            durability=DurabilityPolicy.VOLATILE # Only receive from active publishers\n        )\n\n        # Create a subscriber that will listen for String messages on the 'topic' topic\n        # We use the command_qos_profile here, imagining this subscriber might be a motor controller\n        self.subscription = self.create_subscription(\n            String,\n            'topic',\n            self.listener_callback,\n            command_qos_profile # Use the defined QoS profile\n        )\n        self.subscription # prevent unused variable warning\n        self.get_logger().info(f'MinimalSubscriber started with QoS: Reliability={command_qos_profile.reliability.name}, Depth={command_qos_profile.depth}')\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MinimalSubscriber()\n    try:\n        rclpy.spin(node) # Keep the node alive\n    except KeyboardInterrupt:\n        node.get_logger().info('Subscriber node stopped cleanly.')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n# To make this node executable, add to setup.py:\n# entry_points={\n#     'console_scripts': [\n#         'minimal_subscriber = my_robot_pkg.minimal_subscriber:main',\n#     ],\n# },\n"})}),"\n",(0,r.jsx)(n.h3,{id:"\ufe0f-common-pitfalls-sim-vs-real",children:"\u26a0\ufe0f Common Pitfalls (Sim vs. Real)"}),"\n",(0,r.jsx)(n.p,{children:":::translate:::"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simulation"}),': In simulation, network latency is negligible, and message delivery is almost always perfect. This can lead to a "happy path" mentality where QoS settings seem unimportant.']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reality"}),": On a physical robot, topics are transmitted over real networks (Ethernet, Wi-Fi, serial). This introduces:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Latency"}),": High-frequency sensor data (e.g., a 60Hz camera feed) might experience delays if processed by many nodes or transmitted over slow links. For time-critical control loops, even a few milliseconds of latency can cause oscillations or instability in a physical robot."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message Loss"}),": Wireless networks are prone to interference and packet loss. If your control commands are ",(0,r.jsx)(n.code,{children:"Best Effort"})," and a message is lost, the robot might not receive a critical stop command, leading to collision or falls."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronization Issues"}),": If a node processes data from multiple topics (e.g., camera and IMU), differing publication rates and network delays can lead to unsynchronized data, causing algorithms like SLAM to drift or fail."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hardware Overload"}),": Publishing very large messages (e.g., uncompressed 4K images) at high rates can saturate the network or the edge device's CPU, impacting all other nodes."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fix"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Appropriate QoS"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Control Commands (",(0,r.jsx)(n.code,{children:"/cmd_vel"}),", ",(0,r.jsx)(n.code,{children:"/joint_commands"}),")"]}),": ALWAYS use ",(0,r.jsx)(n.code,{children:"Reliable"})," reliability. Ensure the ",(0,r.jsx)(n.code,{children:"depth"})," is appropriate (often ",(0,r.jsx)(n.code,{children:"1"})," to only process the latest command)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["High-Frequency Sensor Data (",(0,r.jsx)(n.code,{children:"/camera/image_raw"}),", ",(0,r.jsx)(n.code,{children:"/scan"}),")"]}),": Use ",(0,r.jsx)(n.code,{children:"Best Effort"})," reliability and a small ",(0,r.jsx)(n.code,{children:"depth"})," (e.g., ",(0,r.jsx)(n.code,{children:"1"})," to ",(0,r.jsx)(n.code,{children:"5"}),"). Prioritize fresh data."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bandwidth Management"}),": Compress large data types (e.g., ",(0,r.jsx)(n.code,{children:"sensor_msgs/CompressedImage"})," for camera feeds). Reduce publication rates if not strictly necessary."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hardware Acceleration"}),": Utilize hardware acceleration (e.g., NVIDIA's ",(0,r.jsx)(n.code,{children:"image_transport"})," for GPU-accelerated image compression/decompression) on Jetson devices to offload CPU."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Synchronization"}),": Implement robust time synchronization (e.g., NTP for system clocks, ",(0,r.jsx)(n.code,{children:"message_filters.ApproximateTimeSynchronizer"})," for ROS 2 messages) to handle data from multiple sensors."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"-verification",children:"\ud83e\uddea Verification"}),"\n",(0,r.jsx)(n.p,{children:':::translate:::\nFirst, ensure your package is built and sourced as described in the "ROS 2 Nodes" verification section.'}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Run the Publisher Node"})," (in one terminal):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 run my_robot_pkg minimal_publisher\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You should see output indicating messages being published: ",(0,r.jsx)(n.code,{children:'[INFO] [minimal_publisher]: Publishing: "Hello World: 0"'})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Run the Subscriber Node"})," (in a separate terminal):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 run my_robot_pkg minimal_subscriber\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You should see output indicating messages being received: ",(0,r.jsx)(n.code,{children:'[INFO] [minimal_subscriber]: I heard: "Hello World: 0"'})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inspect Topics"})," (in a third terminal):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["List active topics:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 topic list\n"})}),"\n","You should see ",(0,r.jsx)(n.code,{children:"/topic"})," in the list."]}),"\n",(0,r.jsxs)(n.li,{children:["Echo messages on the topic:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 topic echo /topic\n"})}),"\n","This will display the ",(0,r.jsx)(n.code,{children:"String"})," messages being published, confirming data flow."]}),"\n",(0,r.jsxs)(n.li,{children:["Check topic information (type, publishers, subscribers, QoS):","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 topic info /topic --verbose\n"})}),"\n","This command is invaluable for debugging, as it shows the message type, the number of publishers and subscribers, and crucially, the ",(0,r.jsx)(n.strong,{children:"QoS profile"})," for each connection. This helps verify that your chosen QoS settings are active."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-theory-ros-2-services",children:"\ud83e\udde0 Theory: ROS 2 Services"}),"\n",(0,r.jsxs)(n.p,{children:[":::translate:::\nWhile Topics provide asynchronous, one-to-many communication, ",(0,r.jsx)(n.strong,{children:"Services"})," offer a synchronous, request-response communication model. This is ideal when a node needs to explicitly request a computation or an action from another node and then wait for a response."]}),"\n",(0,r.jsxs)(n.p,{children:["Think of it like a remote procedure call. A ",(0,r.jsx)(n.code,{children:"NavigationNode"})," might need to know the current battery level. Instead of subscribing to a ",(0,r.jsx)(n.code,{children:"/battery_status"})," topic (which might not update frequently or be relevant for every query), it can call a ",(0,r.jsx)(n.code,{children:"BatteryMonitorNode"}),"'s ",(0,r.jsx)(n.code,{children:"/get_battery_status"})," service. The ",(0,r.jsx)(n.code,{children:"NavigationNode"})," sends a request, waits, and receives a response containing the battery data."]}),"\n",(0,r.jsx)(n.p,{children:"This synchronous nature means the calling node is blocked until the service returns a response or a timeout occurs. Services are well-suited for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Configuration changes (e.g., setting a motor PID gain)."}),"\n",(0,r.jsxs)(n.li,{children:["Triggering specific actions (e.g., ",(0,r.jsx)(n.code,{children:"take_picture"}),", ",(0,r.jsx)(n.code,{children:"start_slam"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Querying current state (e.g., ",(0,r.jsx)(n.code,{children:"get_map"}),", ",(0,r.jsx)(n.code,{children:"get_joint_state"}),")."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"\ufe0f-architecture-1",children:"\ud83d\udee0\ufe0f Architecture"}),"\n",(0,r.jsx)(n.p,{children:"A client node requesting a service from a server node."}),"\n",(0,r.jsx)(n.mermaid,{value:"graph LR\n    A[NavigationNode] -- Request/Response --\x3e B[BatteryMonitorNode]\n    A -- Call Service --\x3e B(GetBatteryStatus Service)"}),"\n",(0,r.jsx)(n.h3,{id:"-implementation-1",children:"\ud83d\udcbb Implementation"}),"\n",(0,r.jsxs)(n.p,{children:["This example demonstrates a simple service server and client. The ",(0,r.jsx)(n.code,{children:"AddTwoIntsServer"})," node provides a service that adds two integers, and the ",(0,r.jsx)(n.code,{children:"AddTwoIntsClient"})," node calls this service."]}),"\n",(0,r.jsx)(n.p,{children:"Context: These files would typically live at:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"/home/abdullahiqbal/Abdullah/hackathon-book-project/src/my_robot_pkg/my_robot_pkg/add_two_ints_server.py"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"/home/abdullahiqbal/Abdullah/hackathon-book-project/src/my_robot_pkg/my_robot_pkg/add_two_ints_client.py"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["First, you'll need a service definition file. Create a ",(0,r.jsx)(n.code,{children:"srv"})," directory in your ",(0,r.jsx)(n.code,{children:"my_robot_pkg"})," and add ",(0,r.jsx)(n.code,{children:"AddTwoInts.srv"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"Context: This file would typically live at /home/abdullahiqbal/Abdullah/hackathon-book-project/src/my_robot_pkg/srv/AddTwoInts.srv"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"int64 a\nint64 b\n---\nint64 sum\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You'll also need to modify ",(0,r.jsx)(n.code,{children:"setup.py"})," and ",(0,r.jsx)(n.code,{children:"package.xml"})," to build this custom service message."]}),"\n",(0,r.jsxs)(n.h4,{id:"packagexml-modification-inside-my_robot_pkgpackagexml",children:[(0,r.jsx)(n.code,{children:"package.xml"})," modification (inside ",(0,r.jsx)(n.code,{children:"<my_robot_pkg>/package.xml"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Add these lines:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<build_depend>rosidl_default_generators</build_depend>\n<exec_depend>rosidl_default_runtime</exec_depend>\n<member_of_group>rosidl_interface_packages</member_of_group>\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"setuppy-modification-inside-my_robot_pkgsetuppy",children:[(0,r.jsx)(n.code,{children:"setup.py"})," modification (inside ",(0,r.jsx)(n.code,{children:"<my_robot_pkg>/setup.py"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Add these imports and configuration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import os\nfrom glob import glob\nfrom setuptools import setup\n\npackage_name = 'my_robot_pkg'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        # Include all srv files\n        (os.path.join('share', package_name, 'srv'), glob('srv/*.srv')),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='your_name',\n    maintainer_email='your_email@example.com',\n    description='TODO: Package description',\n    license='TODO: License declaration',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'my_first_node = my_robot_pkg.my_first_node:main',\n            'minimal_publisher = my_robot_pkg.minimal_publisher:main',\n            'minimal_subscriber = my_robot_pkg.minimal_subscriber:main',\n            'add_two_ints_server = my_robot_pkg.add_two_ints_server:main',\n            'add_two_ints_client = my_robot_pkg.add_two_ints_client:main',\n        ],\n    },\n)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now for the service server and client code:"}),"\n",(0,r.jsxs)(n.h4,{id:"add-two-ints-server-add_two_ints_serverpy",children:["Add Two Ints Server (",(0,r.jsx)(n.code,{children:"add_two_ints_server.py"}),")"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom my_robot_pkg.srv import AddTwoInts # Import your custom service type\n\nclass AddTwoIntsServer(Node):\n    \"\"\"\n    A ROS 2 Node that provides an 'add_two_ints' service.\n    \"\"\"\n    def __init__(self):\n        super().__init__('add_two_ints_server')\n        # Create a service with the name 'add_two_ints' and the AddTwoInts service type\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n        self.get_logger().info('Add Two Ints Service Server started.')\n\n    def add_two_ints_callback(self, request, response):\n        \"\"\"\n        Callback function for the service. It receives a request and fills a response.\n        \"\"\"\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}')\n        self.get_logger().info(f'Sending response: sum={response.sum}')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = AddTwoIntsServer()\n    try:\n        rclpy.spin(node) # Keep the node alive, waiting for service calls\n    except KeyboardInterrupt:\n        node.get_logger().info('Service server node stopped cleanly.')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"add-two-ints-client-add_two_ints_clientpy",children:["Add Two Ints Client (",(0,r.jsx)(n.code,{children:"add_two_ints_client.py"}),")"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom my_robot_pkg.srv import AddTwoInts # Import your custom service type\nimport sys # For command line arguments\n\nclass AddTwoIntsClient(Node):\n    \"\"\"\n    A ROS 2 Node that calls the 'add_two_ints' service.\n    \"\"\"\n    def __init__(self):\n        super().__init__('add_two_ints_client')\n        # Create a service client for the 'add_two_ints' service\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n\n        # Wait for the service to be available. This is blocking.\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            if not rclpy.ok():\n                self.get_logger().error('Interrupted while waiting for the service. Exiting.')\n                sys.exit(0)\n            self.get_logger().info('Service not available, waiting again...')\n\n        self.req = AddTwoInts.Request() # Create an empty service request object\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.get_logger().info(f'Calling service with a={self.req.a}, b={self.req.b}')\n        # Make the asynchronous service call\n        self.future = self.cli.call_async(self.req)\n        # Spin until the future is complete (response received or error)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    # Check for command line arguments\n    if len(sys.argv) != 3:\n        node = rclpy.create_node('add_two_ints_client_error')\n        node.get_logger().info('Usage: ros2 run my_robot_pkg add_two_ints_client <int_a> <int_b>')\n        node.destroy_node()\n        sys.exit(1)\n\n    client_node = AddTwoIntsClient()\n    a = int(sys.argv[1])\n    b = int(sys.argv[2])\n\n    response = client_node.send_request(a, b)\n\n    if response is not None:\n        client_node.get_logger().info(f'Result of add_two_ints: sum = {response.sum}')\n    else:\n        client_node.get_logger().error('Service call failed.')\n\n    client_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n# To make this node executable, add to setup.py:\n# entry_points={\n#     'console_scripts': [\n#         'minimal_subscriber = my_robot_pkg.minimal_subscriber:main',\n#     ],\n# },\n"})}),"\n",(0,r.jsx)(n.h3,{id:"\ufe0f-common-pitfalls-sim-vs-real-1",children:"\u26a0\ufe0f Common Pitfalls (Sim vs. Real)"}),"\n",(0,r.jsx)(n.p,{children:":::translate:::"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simulation"}),": Service calls in simulation are typically instantaneous, and service servers are always available. This can lead to design choices that don't account for real-world latencies or failures."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reality"}),": On a physical robot, service calls are synchronous and blocking. This means:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Blocking Calls"}),": If a client node calls a service and the server is busy, slow, or crashed, the client node will be blocked until a response or timeout. This can freeze the robot's control loop if not handled asynchronously, leading to jerky movements or a frozen state."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Timeouts"}),": Services need to complete within a reasonable time. If a complex computation or a physical action (like moving a joint) takes longer than expected, the client might timeout, assuming failure, even if the server is still working."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Availability"}),": In a distributed system with many nodes on an edge device, a service server might not be running yet, or it might crash. Clients must gracefully handle unavailable services, or the system will fail to initialize or recover."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fix"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous Service Clients"}),": For critical control paths, consider making service calls asynchronous and handling the response in a separate callback or thread to avoid blocking the main loop. ",(0,r.jsx)(n.code,{children:"rclpy"}),"'s ",(0,r.jsx)(n.code,{children:"call_async"})," method facilitates this."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensible Timeouts"}),": Always set realistic timeouts for ",(0,r.jsx)(n.code,{children:"wait_for_service"})," and for the service calls themselves."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Handling"}),": Implement robust error handling in both client and server. What happens if the service request is invalid? What if the server encounters an internal error?"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Availability Checks"}),": Clients should always use ",(0,r.jsx)(n.code,{children:"wait_for_service()"})," before attempting to call a service, especially during startup."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimize Blocking Operations"}),": If a service server needs to perform a long-running task, it should ideally process the request in a separate thread to avoid blocking other client requests."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"-verification-1",children:"\ud83e\uddea Verification"}),"\n",(0,r.jsxs)(n.p,{children:[":::translate:::\nFirst, ensure your package (including the ",(0,r.jsx)(n.code,{children:"AddTwoInts.srv"}),' file) is built and sourced as described in the "ROS 2 Nodes" verification section. You must re-run ',(0,r.jsx)(n.code,{children:"colcon build"})," after adding the ",(0,r.jsx)(n.code,{children:".srv"})," file and modifying ",(0,r.jsx)(n.code,{children:"setup.py"})," and ",(0,r.jsx)(n.code,{children:"package.xml"}),"."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Run the Service Server Node"})," (in one terminal):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 run my_robot_pkg add_two_ints_server\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You should see ",(0,r.jsx)(n.code,{children:"[INFO] [add_two_ints_server]: Add Two Ints Service Server started."})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Call the Service using ",(0,r.jsx)(n.code,{children:"ros2 service call"})]})," (in a separate terminal):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'ros2 service call /add_two_ints my_robot_pkg/srv/AddTwoInts "{a: 5, b: 3}"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You should see the client terminal outputting ",(0,r.jsx)(n.code,{children:"sum: 8"}),", and the server terminal showing the incoming request and outgoing response."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Run the Service Client Node"})," (in a third terminal):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 run my_robot_pkg add_two_ints_client 10 20\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The client node will connect, call the service with ",(0,r.jsx)(n.code,{children:"a=10"})," and ",(0,r.jsx)(n.code,{children:"b=20"}),", and then print the result ",(0,r.jsx)(n.code,{children:"sum = 30"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inspect Services"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["List active services:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 service list\n"})}),"\n","You should see ",(0,r.jsx)(n.code,{children:"/add_two_ints"})," in the list."]}),"\n",(0,r.jsxs)(n.li,{children:["Get information about the service:","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ros2 service info /add_two_ints\n"})}),"\n","This will show the service type, server, and client nodes connected to it."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"-chapter-summary",children:"\ud83d\udcdd Chapter Summary"}),"\n",(0,r.jsxs)(n.p,{children:[":::translate:::\nIn this chapter, we've dissected the foundational elements of ROS 2: ",(0,r.jsx)(n.strong,{children:"Nodes"}),", ",(0,r.jsx)(n.strong,{children:"Topics"}),", and ",(0,r.jsx)(n.strong,{children:"Services"}),'. We learned that Nodes are the modular, single-purpose processes forming the robot\'s distributed "brain." Topics provide an asynchronous, publish-subscribe mechanism crucial for fluid data flow, with ',(0,r.jsx)(n.strong,{children:"Quality of Service (QoS)"})," settings acting as critical directives for reliability and latency in physical systems. Services, on the other hand, offer a synchronous request-response interaction, essential for explicit actions and state queries."]}),"\n",(0,r.jsxs)(n.p,{children:["Understanding the stark differences between ",(0,r.jsx)(n.strong,{children:"Simulation and Reality"})," for each of these concepts is paramount. Latency, resource constraints, and communication reliability are abstract challenges in a simulator but become physical realities that can cause a robot to fail, fall, or even self-damage. By carefully defining QoS, structuring nodes for efficient edge computing, and anticipating real-world communication pitfalls, you are not just writing code\u2014you are orchestrating the safe and precise movement of atoms."]}),"\n",(0,r.jsx)(n.h3,{id:"-conclusion",children:"\ud83d\udd1a Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"We have now established the nervous system of our robot. Nodes can think, Topics can share senses, and Services can request actions. This infrastructure is powerful, but it is currently blind. In the next module, we will connect this nervous system to eyes and lasers, exploring how to capture and process the rich sensory data that allows a physical AI to perceive its world.\n:::"})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);