"use strict";(globalThis.webpackChunktmp_docusaurus_project=globalThis.webpackChunktmp_docusaurus_project||[]).push([[8018],{3159:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-5/project-3-office-runner","title":"Project 3: Office Runner \u2013 Autonomous Item Delivery","description":"\ud83c\udfaf Objective","source":"@site/docs/module-5/project-3-office-runner.md","sourceDirName":"module-5","slug":"/module-5/project-3-office-runner","permalink":"/hackathon-book-project/docs/module-5/project-3-office-runner","draft":false,"unlisted":false,"editUrl":"https://github.com/EngineerAbdullahIqbal/hackathon-book-project/tree/main/tmp_docusaurus_project/docs/module-5/project-3-office-runner.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Project 2: Visual Sorter Arm \u2013 Object Identification and Sorting","permalink":"/hackathon-book-project/docs/module-5/project-2-visual-sorter"}}');var i=r(4848),s=r(8453);const t={},a="Project 3: Office Runner \u2013 Autonomous Item Delivery",l={},c=[{value:"\ud83c\udfaf Objective",id:"-objective",level:3},{value:"\ud83e\udde0 Theory: Autonomous Navigation with Nav2",id:"-theory-autonomous-navigation-with-nav2",level:3},{value:"\ud83d\udee0\ufe0f Architecture",id:"\ufe0f-architecture",level:3},{value:"\ud83d\udcbb Implementation",id:"-implementation",level:3},{value:"\u26a0\ufe0f Common Pitfalls (Sim vs. Real)",id:"\ufe0f-common-pitfalls-sim-vs-real",level:3},{value:"\ud83e\uddea Verification",id:"-verification",level:3}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"project-3-office-runner--autonomous-item-delivery",children:"Project 3: Office Runner \u2013 Autonomous Item Delivery"})}),"\n",(0,i.jsx)(n.h3,{id:"-objective",children:"\ud83c\udfaf Objective"}),"\n",(0,i.jsx)(n.p,{children:"The student will implement an autonomous mobile robot using ROS 2 and Nav2 to navigate a predefined map and simulate item delivery to specific locations."}),"\n",(0,i.jsx)(n.h3,{id:"-theory-autonomous-navigation-with-nav2",children:"\ud83e\udde0 Theory: Autonomous Navigation with Nav2"}),"\n",(0,i.jsx)(n.p,{children:"Autonomous navigation is a cornerstone of robotics, enabling robots to move from one point to another without constant human intervention. In ROS 2, the Nav2 stack provides a comprehensive set of tools for this purpose."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ROS 2 Actions for Long-Running Tasks"}),": Unlike topics (continuous data streams) or services (single request-response), ROS 2 Actions are designed for goal-oriented, long-duration tasks. For autonomous navigation, the ",(0,i.jsx)(n.code,{children:"NavigateToPose"})," action is crucial. You send a target pose (x, y, yaw) as a goal, receive continuous feedback on the robot's progress, and eventually a result indicating success or failure. This robust communication pattern is essential when a physical robot might be navigating for minutes and needs to report its status periodically."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Nav2 Stack Components"}),": Nav2 is a modular system, with each component specializing in a part of the navigation challenge:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"map_server"})}),": Loads and provides the robot with a static map of the environment."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"amcl"})," (Adaptive Monte Carlo Localization)"]}),": This node is responsible for ",(0,i.jsx)(n.em,{children:"localization"}),"\u2014determining the robot's current pose within a known map. It uses a particle filter, processing sensor data (like lidar scans) and odometry estimates to track the robot's position. On a real robot, AMCL combats odometry drift, which is inevitable due to wheel slip and sensor noise."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"bt_navigator"})," (Behavior Tree Navigator)"]}),": The brain of Nav2, orchestrating high-level behaviors defined in a Behavior Tree. When a ",(0,i.jsx)(n.code,{children:"NavigateToPose"})," action goal is received, the ",(0,i.jsx)(n.code,{children:"bt_navigator"})," executes a pre-defined sequence of actions, such as planning a global path, following it locally, and handling recovery behaviors."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"planner_server"})}),": Generates a global path from the robot's current location to the goal."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"controller_server"})}),": Executes the global path by generating velocity commands (",(0,i.jsx)(n.code,{children:"/cmd_vel"}),") for the robot's motors, while avoiding local obstacles."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"smoother_server"})}),": Refines paths for smoother execution."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Behavior Trees (BTs)"}),': Behavior Trees provide a hierarchical, state-machine-like structure to define complex robot behaviors. For "Office Runner," a BT will define the sequence of ',(0,i.jsx)(n.code,{children:"NavigateToPose"})," actions required to deliver items, potentially incorporating ",(0,i.jsx)(n.code,{children:"Wait"})," actions or recovery strategies. They are critical for managing the robot's responses to its environment and mission goals in a structured, fault-tolerant manner."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-architecture",children:"\ud83d\udee0\ufe0f Architecture"}),"\n",(0,i.jsxs)(n.p,{children:['The "Office Runner" system involves a Python node (',(0,i.jsx)(n.code,{children:"delivery_manager.py"}),") sending navigation goals to the Nav2 stack, which then controls the robot. The localization and navigation components work in concert to achieve autonomous movement."]}),"\n",(0,i.jsx)(n.mermaid,{value:"graph LR\n    subgraph Office Runner Components\n        A[delivery_manager.py] -- send_goal --\x3e B(NavigateToPose.action)\n    end\n\n    subgraph Nav2 Stack\n        B -- goal --\x3e C{bt_navigator}\n        C -- plans --\x3e D[planner_server]\n        C -- controls --\x3e E[controller_server]\n        E -- /cmd_vel --\x3e F[Robot Base Controller]\n        F -- odometry --\x3e G(amcl)\n        G -- /tf --\x3e H[tf_static (map->odom)]\n        I[map_server] -- /map --\x3e G\n        J[LiDAR Sensor] -- /scan --\x3e G\n    end\n\n    H -- /tf --\x3e G\n    G -- /tf --\x3e E\n    K[robot_state_publisher] -- /tf --\x3e L[tf_static (odom->base_link)]\n    L -- /tf --\x3e E\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#add8e6,stroke:#333,stroke-width:2px\n    style C fill:#ccffcc,stroke:#333,stroke-width:2px\n    style D fill:#ffcc99,stroke:#333,stroke-width:2px\n    style E fill:#ffff99,stroke:#333,stroke-width:2px\n    style F fill:#dddddd,stroke:#333,stroke-width:2px\n    style G fill:#ccccff,stroke:#333,stroke-width:2px\n    style H fill:#e0e0e0,stroke:#333,stroke-width:2px\n    style I fill:#f0f8ff,stroke:#333,stroke-width:2px\n    style J fill:#f0f0f0,stroke:#333,stroke-width:2px\n    style K fill:#e0e0e0,stroke:#333,stroke-width:2px\n    style L fill:#e0e0e0,stroke:#333,stroke-width:2px"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"TF (Transform) Tree"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"map"})," (world frame, provided by ",(0,i.jsx)(n.code,{children:"map_server"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"odom"})," (odometry frame, provided by robot's odometry source, e.g., wheel encoders)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"base_link"})," (robot's origin, typically center of its base)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"laser_frame"})," (LiDAR sensor frame, attached to ",(0,i.jsx)(n.code,{children:"base_link"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"amcl"})," node computes the transform from ",(0,i.jsx)(n.code,{children:"map"})," to ",(0,i.jsx)(n.code,{children:"odom"}),", aligning the robot's local odometry with the global map. The ",(0,i.jsx)(n.code,{children:"robot_state_publisher"})," ensures ",(0,i.jsx)(n.code,{children:"odom"})," to ",(0,i.jsx)(n.code,{children:"base_link"})," and ",(0,i.jsx)(n.code,{children:"base_link"})," to sensor frames are correctly published."]}),"\n",(0,i.jsx)(n.h3,{id:"-implementation",children:"\ud83d\udcbb Implementation"}),"\n",(0,i.jsx)(n.p,{children:"The implementation focuses on setting up the necessary ROS 2 infrastructure and a Python node to interact with Nav2."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Create ROS 2 Package"})}),"\n",(0,i.jsxs)(n.p,{children:["First, create a new ROS 2 Python package called ",(0,i.jsx)(n.code,{children:"office_runner"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 pkg create --build-type ament_python office_runner\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Placeholder Map Files"})}),"\n",(0,i.jsxs)(n.p,{children:["Inside your ",(0,i.jsx)(n.code,{children:"office_runner"})," package, create a ",(0,i.jsx)(n.code,{children:"maps"})," directory and add placeholder files:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"mkdir -p office_runner/maps\ntouch office_runner/maps/office_map.yaml\ntouch office_runner/maps/office_map.pgm\n"})}),"\n",(0,i.jsx)(n.p,{children:"You would later replace these with actual map files generated from SLAM."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Launch Files"})}),"\n",(0,i.jsxs)(n.p,{children:["Create ",(0,i.jsx)(n.code,{children:"launch"})," directory inside ",(0,i.jsx)(n.code,{children:"office_runner"})," and add the following launch files."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"/home/abdullahiqbal/Abdullah/hackathon-book-project/office_runner/launch/localization.launch.py"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Get the path to the office_runner package\n    office_runner_share_dir = get_package_share_directory('office_runner')\n    map_file_path = os.path.join(office_runner_share_dir, 'maps', 'office_map.yaml')\n\n    return LaunchDescription([\n        Node(\n            package='nav2_map_server',\n            executable='map_server',\n            name='map_server',\n            output='screen',\n            parameters=[{'yaml_filename': map_file_path}]\n        ),\n        Node(\n            package='nav2_amcl',\n            executable='amcl',\n            name='amcl',\n            output='screen',\n            parameters=[{\n                'use_sim_time': True, # Set to False for real robot\n                'scan_topic': 'scan',\n                'global_frame_id': 'map',\n                'odom_frame_id': 'odom',\n                'base_frame_id': 'base_link',\n                # Add AMCL specific parameters here\n            }]\n        ),\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            name='robot_state_publisher',\n            output='screen',\n            parameters=[{'use_sim_time': True}] # Ensure this matches simulation if used\n            # Arguments for URDF description should be added here for real robot\n        ),\n        # You would typically add a static_transform_publisher for map to odom if your AMCL isn't providing it directly,\n        # or if you need an initial pose. Nav2 AMCL provides map->odom implicitly.\n    ])\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Context"}),": This launch file is responsible for loading the map and localizing the robot within it."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hardware Constraint"}),": For a Jetson Orin Nano, these nodes (especially AMCL with a high particle count) can be CPU-intensive. The ",(0,i.jsx)(n.code,{children:"use_sim_time"})," parameter is critical: ",(0,i.jsx)(n.code,{children:"True"})," for simulation, ",(0,i.jsx)(n.code,{children:"False"})," for real hardware."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"/home/abdullahiqbal/Abdullah/hackathon-book-project/office_runner/launch/navigation.launch.py"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom nav2_common.launch import RewrittenYaml\n\ndef generate_launch_description():\n    # Get the path to the office_runner package\n    office_runner_share_dir = get_package_share_directory('office_runner')\n    nav2_bringup_share_dir = get_package_share_directory('nav2_bringup')\n\n    # Placeholder for Nav2 parameters - you would have a YAML file here\n    nav2_params_file = os.path.join(office_runner_share_dir, 'config', 'nav2_params.yaml')\n\n    # Create a dummy nav2_params.yaml if it doesn't exist to prevent errors during initial setup\n    config_dir = os.path.join(office_runner_share_dir, 'config')\n    if not os.path.exists(config_dir):\n        os.makedirs(config_dir)\n    if not os.path.exists(nav2_params_file):\n        with open(nav2_params_file, 'w') as f:\n            f.write(\"use_sim_time: True\\n\") # Default to sim time for initial setup\n            f.write(\"controller_server:\\n\")\n            f.write(\"  ros__parameters:\\n\")\n            f.write(\"    min_x_velocity_threshold: 0.001\\n\")\n            f.write(\"    min_y_velocity_threshold: 0.001\\n\")\n            f.write(\"    min_z_angular_velocity_threshold: 0.001\\n\")\n            f.write(\"planner_server:\\n\")\n            f.write(\"  ros__parameters:\\n\")\n            f.write(\"    PlannerServer:\\n\")\n            f.write(\"      use_sim_time: True\\n\")\n            f.write(\"recovery_server:\\n\")\n            f.write(\"  ros__parameters:\\n\")\n            f.write(\"    recovery_behaviour_trees_config_file: \" + os.path.join(nav2_bringup_share_dir, 'behavior_trees', 'navigate_w_replanning_and_recovery.xml') + \"\\n\")\n            f.write(\"bt_navigator:\\n\")\n            f.write(\"  ros__parameters:\\n\")\n            f.write(\"    use_sim_time: True\\n\")\n            f.write(\"    default_nav_to_pose_bt_xml: \" + os.path.join(office_runner_share_dir, 'behavior_trees', 'delivery_routine.xml') + \"\\n\")\n            f.write(\"smoother_server:\\n\")\n            f.write(\"  ros__parameters:\\n\")\n            f.write(\"    use_sim_time: True\\n\")\n\n\n    # Nav2 uses a common parameter file\n    configured_params = RewrittenYaml(\n            source_file=nav2_params_file,\n            root_key='',\n            param_rewrites={'use_sim_time': 'true'}, # This will be overridden by the individual nodes' parameters\n            convert_types=True)\n\n\n    return LaunchDescription([\n        Node(\n            package='nav2_controller',\n            executable='controller_server',\n            name='controller_server',\n            output='screen',\n            parameters=[configured_params, {'use_sim_time': True}]\n        ),\n        Node(\n            package='nav2_planner',\n            executable='planner_server',\n            name='planner_server',\n            output='screen',\n            parameters=[configured_params, {'use_sim_time': True}]\n        ),\n        Node(\n            package='nav2_smoother',\n            executable='smoother_server',\n            name='smoother_server',\n            output='screen',\n            parameters=[configured_params, {'use_sim_time': True}]\n        ),\n        Node(\n            package='nav2_behaviors',\n            executable='behavior_server',\n            name='behavior_server',\n            output='screen',\n            parameters=[configured_params, {'use_sim_time': True}]\n        ),\n        Node(\n            package='nav2_bt_navigator',\n            executable='bt_navigator',\n            name='bt_navigator',\n            output='screen',\n            parameters=[configured_params, {'use_sim_time': True,\n                                            'default_nav_to_pose_bt_xml': os.path.join(office_runner_share_dir, 'behavior_trees', 'delivery_routine.xml')}]\n        ),\n        Node(\n            package='nav2_lifecycle_manager',\n            executable='lifecycle_manager_node',\n            name='lifecycle_manager_navigation',\n            output='screen',\n            parameters=[{'autostart': True,\n                         'node_names': ['controller_server',\n                                        'planner_server',\n                                        'smoother_server',\n                                        'behavior_server',\n                                        'bt_navigator']}]\n        )\n    ])\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Context"}),": This launch file brings up the core navigation components of Nav2."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hardware Constraint"}),": The path planning and control algorithms run continuously, demanding consistent CPU cycles. On a Jetson Orin, optimizing these parameters (e.g., ",(0,i.jsx)(n.code,{children:"controller_frequency"}),", ",(0,i.jsx)(n.code,{children:"planner_frequency"}),") is crucial to meet latency requirements for motor control. Setting ",(0,i.jsx)(n.code,{children:"use_sim_time"})," to ",(0,i.jsx)(n.code,{children:"False"})," for real hardware is critical."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Behavior Tree"})}),"\n",(0,i.jsxs)(n.p,{children:["Create a ",(0,i.jsx)(n.code,{children:"behavior_trees"})," directory inside ",(0,i.jsx)(n.code,{children:"office_runner"})," and add a placeholder behavior tree."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"/home/abdullahiqbal/Abdullah/hackathon-book-project/office_runner/behavior_trees/delivery_routine.xml"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<root main_tree_to_execute="MainTree">\n    <BehaviorTree ID="MainTree">\n        <Sequence name="DeliverySequence">\n            \x3c!-- Go to the first delivery point --\x3e\n            <Action ID="NavigateToPose" name="GoToPointA"/>\n            \x3c!-- Wait for a moment to simulate item drop-off --\x3e\n            <Action ID="Wait" duration="5.0"/>\n            \x3c!-- Go to the second delivery point --\x3e\n            <Action ID="NavigateToPose" name="GoToPointB"/>\n        </Sequence>\n    </BehaviorTree>\n\n    \x3c!-- Node definitions --\x3e\n    <TreeNodesModel>\n        <Action ID="NavigateToPose">\n            <input_port name="pose">Target pose (geometry_msgs/PoseStamped)</input_port>\n        </Action>\n        <Action ID="Wait">\n            <input_port name="duration">Wait duration in seconds</input_port>\n        </Action>\n    </TreeNodesModel>\n</root>\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Context"}),": This XML defines a simple sequence for the robot: navigate to point A, wait, then navigate to point B. This is the ",(0,i.jsx)(n.code,{children:"delivery_routine"})," that ",(0,i.jsx)(n.code,{children:"bt_navigator"})," will execute."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["5. Python Node (",(0,i.jsx)(n.code,{children:"delivery_manager.py"}),")"]})}),"\n",(0,i.jsxs)(n.p,{children:["Create a ",(0,i.jsx)(n.code,{children:"delivery_manager.py"})," file in the ",(0,i.jsx)(n.code,{children:"office_runner/office_runner"})," directory (inside the Python package)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"/home/abdullahiqbal/Abdullah/hackathon-book-project/office_runner/office_runner/delivery_manager.py"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy\n\nfrom nav2_msgs.action import NavigateToPose\nfrom geometry_msgs.msg import PoseStamped\n\n# To ensure this node is discoverable by ROS 2\n# Add the following to setup.py in the 'entry_points' section:\n# 'console_scripts': [\n#     'delivery_manager = office_runner.delivery_manager:main',\n# ],\n\nclass DeliveryManager(Node):\n    def __init__(self):\n        super().__init__('delivery_manager')\n        self._action_client = ActionClient(\n            self,\n            NavigateToPose,\n            'navigate_to_pose',\n            qos_profile=QoSProfile(\n                reliability=ReliabilityPolicy.RELIABLE,\n                history=HistoryPolicy.KEEP_LAST,\n                depth=1,\n                durability=DurabilityPolicy.VOLATILE\n            )\n        )\n        self.get_logger().info('Delivery Manager node initialized.')\n\n    def send_goal(self, x, y, yaw):\n        self.get_logger().info('Waiting for navigate_to_pose action server...')\n        self._action_client.wait_for_server()\n\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n        goal_msg.pose.pose.position.x = x\n        goal_msg.pose.pose.position.y = y\n        goal_msg.pose.pose.orientation.z = yaw # Simplified for 2D, assumes yaw in radians\n        goal_msg.pose.pose.orientation.w = 1.0 # For simplicity, assumes no pitch/roll\n\n        self.get_logger().info(f'Sending goal: x={x}, y={y}, yaw={yaw}')\n        self._send_goal_future = self._action_client.send_goal_async(goal_msg)\n\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().error('Goal rejected :(')\n            return\n\n        self.get_logger().info('Goal accepted :)\n')\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        status = future.result().status\n        if status == 4: # GoalStatus.SUCCEEDED\n            self.get_logger().info('Goal succeeded!')\n        else:\n            self.get_logger().error(f'Goal failed with status: {status}')\n        rclpy.shutdown() # Shutdown the node after goal completion or failure\n\ndef main(args=None):\n    rclpy.init(args=args)\n    delivery_manager = DeliveryManager()\n\n    # Example delivery points\n    # Point A\n    delivery_manager.send_goal(x=1.0, y=1.0, yaw=0.0) # Move 1m forward, 1m left, facing forward\n\n    # After the first goal completes, you could chain another goal here or in a more complex state machine\n    # For simplicity, this example will just shutdown after the first goal.\n    # In a real delivery routine, you would have a sequence of goals.\n\n    rclpy.spin(delivery_manager)\n    # The node will shutdown in get_result_callback\n    delivery_manager.destroy_node()\n    if rclpy.ok():\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Context"}),": This Python node creates an ",(0,i.jsx)(n.code,{children:"ActionClient"})," for ",(0,i.jsx)(n.code,{children:"NavigateToPose"}),", sends a goal, and handles the responses."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hardware Constraint"}),": Running Python nodes on a Jetson Orin Nano incurs overhead. While ",(0,i.jsx)(n.code,{children:"rclpy"})," is optimized, complex Python logic in callback functions can introduce latency. The ",(0,i.jsx)(n.code,{children:"QoSProfile"})," is explicitly defined: ",(0,i.jsx)(n.code,{children:"ReliabilityPolicy.RELIABLE"})," is chosen for control commands to ensure critical goals are delivered, even if it means retransmissions. ",(0,i.jsx)(n.code,{children:"DurabilityPolicy.VOLATILE"})," is typical for actions as old goals are not usually relevant."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Code is Law"}),": Uses ",(0,i.jsx)(n.code,{children:"rclpy"})," class inheritance, ",(0,i.jsx)(n.code,{children:"ActionClient"}),", ",(0,i.jsx)(n.code,{children:"QoSProfile"}),". ",(0,i.jsx)(n.code,{children:"setup.py"})," entry point is commented as a reminder."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-common-pitfalls-sim-vs-real",children:"\u26a0\ufe0f Common Pitfalls (Sim vs. Real)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simulation"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Perfect Odometry"}),": In Gazebo or Isaac Sim, odometry is often perfect, leading to minimal drift and excellent AMCL performance even with sparse sensor data."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ideal Sensors"}),": Sensor data (LiDAR, camera) is noise-free, and lighting conditions are consistent."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Infinite Power"}),": No battery constraints, thermal throttling, or voltage sag. The robot performs identically at all times."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No Unforeseen Obstacles"}),": Dynamic obstacles (people, dropped items) are usually not present unless explicitly simulated."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reality"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Localization Drift"}),': On a physical robot, wheel slippage, bumpy surfaces, and sensor noise (e.g., LiDAR glare on reflective surfaces) cause odometry to drift. AMCL\'s performance becomes highly dependent on map quality, good sensor data, and careful tuning of its parameters. A robot can easily become "lost" if it moves too fast or in an environment with ambiguous features.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Latency in Control Loops"}),": The entire Nav2 stack, from global planning to local control, runs on the robot's onboard computer (e.g., Jetson Orin). If any node in the chain experiences high latency due to CPU/GPU load, memory pressure, or Python overhead, the robot's movements can become jerky, it might overshoot goals, or even oscillate, potentially leading to collisions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Power and Thermal Throttling"}),": Battery voltage sag under heavy motor load affects motor torque and speed, leading to deviations from commanded velocities. High CPU/GPU usage can cause thermal throttling, reducing computational power and increasing latency."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Environments"}),": People walking, doors opening, or unexpected objects are common. Nav2's local planners need to react quickly and safely, which requires robust sensor input and low-latency processing."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Imperfect Collision Avoidance"}),": While Nav2 has collision avoidance, it relies on sensor data. If a small object is below the LiDAR plane or a transparent object is invisible, collisions can occur."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fix"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tuning Nav2 Parameters"}),": Invest significant time in tuning ",(0,i.jsx)(n.code,{children:"amcl"}),", ",(0,i.jsx)(n.code,{children:"controller_server"}),", and ",(0,i.jsx)(n.code,{children:"planner_server"})," parameters for your specific robot and environment. This includes ",(0,i.jsx)(n.code,{children:"update_frequency"}),", ",(0,i.jsx)(n.code,{children:"max_vel_x"}),", ",(0,i.jsx)(n.code,{children:"min_vel_x"}),", ",(0,i.jsx)(n.code,{children:"acc_lim_x"}),", and local planner parameters."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robust Error Handling"}),": Implement more sophisticated error handling in ",(0,i.jsx)(n.code,{children:"delivery_manager.py"})," to react to ",(0,i.jsx)(n.code,{children:"NavigateToPose"})," failures (e.g., retry, request human intervention, switch to a recovery behavior)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor Fusion"}),": Consider fusing multiple sensor types (LiDAR, depth camera, IMU) for more robust localization and obstacle detection."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Monitoring"}),": Actively monitor CPU, memory, and topic latencies (",(0,i.jsx)(n.code,{children:"ros2 topic hz"}),", ",(0,i.jsx)(n.code,{children:"ros2 topic bw"}),") on the edge device to identify bottlenecks."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Slow Down"}),": Often, simply reducing the robot's maximum velocities in the controller parameters (",(0,i.jsx)(n.code,{children:"max_vel_x"}),", ",(0,i.jsx)(n.code,{children:"max_rot_vel"}),") can significantly improve navigation reliability in reality."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.admonition,{type:"danger",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Real-World Collision Risk"}),": Autonomous navigation on a physical robot carries significant risk. Untuned parameters, sensor failures, or unexpected objects can lead to collisions, potentially causing:"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robot Damage"}),": Breaking sensors, motors, or structural components."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Environmental Damage"}),": Hitting furniture, walls, or other equipment."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Personal Injury"}),": Colliding with people, especially at higher speeds.\nAlways test in a controlled environment, start with very low speeds, and be ready to trigger an emergency stop (",(0,i.jsx)(n.code,{children:"E-stop"}),") at all times."]}),"\n"]})]}),"\n",(0,i.jsx)(n.h3,{id:"-verification",children:"\ud83e\uddea Verification"}),"\n",(0,i.jsx)(n.p,{children:'To verify your "Office Runner" setup, follow these steps:'}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Build the ROS 2 Package"}),":","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd /home/abdullahiqbal/Abdullah/hackathon-book-project\ncolcon build --packages-select office_runner\nsource install/setup.bash\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Launch Localization"}),": Open a terminal and run your localization stack (you'll need a simulated robot running in Gazebo/Isaac Sim, or your real robot's drivers).","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 launch office_runner localization.launch.py\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Launch Navigation"}),": Open another terminal.","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 launch office_runner navigation.launch.py\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Set Initial Pose (if using AMCL)"}),": If using AMCL with a static map, you'll need to provide an initial pose estimate in ",(0,i.jsx)(n.code,{children:"rviz2"}),". Open ",(0,i.jsx)(n.code,{children:"rviz2"}),", add a ",(0,i.jsx)(n.code,{children:"Map"})," display, a ",(0,i.jsx)(n.code,{children:"LaserScan"})," display, and an ",(0,i.jsx)(n.code,{children:"AmclPose"}),' display. Use the "2D Pose Estimate" tool in ',(0,i.jsx)(n.code,{children:"rviz2"})," to tell AMCL where the robot approximately is on the map.","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"rviz2\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Run the Delivery Manager"}),": Open a third terminal.","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run office_runner delivery_manager\n"})}),"\n","You should see the ",(0,i.jsx)(n.code,{children:"delivery_manager"})," waiting for the ",(0,i.jsx)(n.code,{children:"navigate_to_pose"})," action server, then sending a goal."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Observe Robot Movement"}),": The simulated (or real) robot should start moving towards the target pose (1.0, 1.0, 0.0) on the map."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitor Topics"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Check the localization quality:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 topic echo /amcl_pose\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Observe the velocity commands being sent to the robot:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 topic echo /cmd_vel\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Check for navigation status and feedback:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 topic list | grep navigate_to_pose\n"})}),"\n","Then, echo the relevant feedback or status topics."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected Outcomes"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The robot will autonomously navigate from its starting position to the target pose (1.0, 1.0, 0.0) defined in ",(0,i.jsx)(n.code,{children:"delivery_manager.py"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["You should observe the robot's pose in ",(0,i.jsx)(n.code,{children:"rviz2"})," updating correctly relative to the loaded map."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"delivery_manager"}),' node will report "Goal accepted :)" and then "Goal succeeded!" (or "Goal rejected/failed") once the navigation task is complete.']}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"ros2 topic echo /cmd_vel"})," output will show varying linear and angular velocities as Nav2 guides the robot."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"ros2 topic echo /amcl_pose"})," output will show ",(0,i.jsx)(n.code,{children:"map"})," frame poses, indicating successful localization within the environment."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>a});var o=r(6540);const i={},s=o.createContext(i);function t(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);