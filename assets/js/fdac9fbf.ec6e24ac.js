"use strict";(globalThis.webpackChunktmp_docusaurus_project=globalThis.webpackChunktmp_docusaurus_project||[]).push([[7384],{2692:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3/chapter-7","title":"Chapter 7: Inverse Kinematics and Humanoid Motion Planning","description":"\ud83c\udfaf Objective","source":"@site/docs/module-3/chapter-7.md","sourceDirName":"module-3","slug":"/module-3/chapter-7","permalink":"/roboailearner/docs/module-3/chapter-7","draft":false,"unlisted":false,"editUrl":"https://github.com/EngineerAbdullahIqbal/roboailearner/tree/main/robotics_book_content/docs/module-3/chapter-7.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 6: Sensor Fusion: Combining Data for Robust Perception","permalink":"/roboailearner/docs/module-2/chapter-6"},"next":{"title":"Chapter 8: Robot Control: Actuators, Joints, and PID","permalink":"/roboailearner/docs/module-3/chapter-8"}}');var o=i(4848),s=i(8453);const r={},a="Chapter 7: Inverse Kinematics and Humanoid Motion Planning",l={},c=[{value:"\ud83c\udfaf Objective",id:"-objective",level:3},{value:"\ud83e\udde0 Theory: The Mathematics of Reaching",id:"-theory-the-mathematics-of-reaching",level:3},{value:"1. Forward Kinematics (FK)",id:"1-forward-kinematics-fk",level:4},{value:"2. Inverse Kinematics (IK)",id:"2-inverse-kinematics-ik",level:4},{value:"3. Motion Planning",id:"3-motion-planning",level:4},{value:"\ud83d\udee0\ufe0f Architecture: MoveIt 2",id:"\ufe0f-architecture-moveit-2",level:3},{value:"\ud83d\udcbb Implementation: Basic FK/IK with Python",id:"-implementation-basic-fkik-with-python",level:3},{value:"\u26a0\ufe0f Common Pitfalls (Sim vs. Real)",id:"\ufe0f-common-pitfalls-sim-vs-real",level:3},{value:"\ud83e\uddea Verification",id:"-verification",level:3},{value:"\ud83d\udcdd Chapter Summary",id:"-chapter-summary",level:3},{value:"\ud83d\udd1a Conclusion",id:"-conclusion",level:3}];function h(e){const n={code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"chapter-7-inverse-kinematics-and-humanoid-motion-planning",children:"Chapter 7: Inverse Kinematics and Humanoid Motion Planning"})}),"\n",(0,o.jsx)(n.h3,{id:"-objective",children:"\ud83c\udfaf Objective"}),"\n",(0,o.jsx)(n.p,{children:"This chapter dives into the geometry of movement. You will learn the difference between Forward Kinematics (FK) and Inverse Kinematics (IK), understand how to calculate joint angles to reach a specific point in space, and explore how motion planning frameworks like MoveIt 2 navigate complex humanoid bodies without collisions."}),"\n",(0,o.jsx)(n.h3,{id:"-theory-the-mathematics-of-reaching",children:"\ud83e\udde0 Theory: The Mathematics of Reaching"}),"\n",(0,o.jsx)(n.p,{children:"To a computer, a robot is a tree of coordinate frames connected by joints. Moving a hand to a coffee cup involves solving a complex geometric puzzle."}),"\n",(0,o.jsx)(n.h4,{id:"1-forward-kinematics-fk",children:"1. Forward Kinematics (FK)"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Question:"}),' "If I set my shoulder to 45\xb0 and elbow to 90\xb0, where is my hand?"']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Mechanism:"})," Chain of transformation matrices."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Difficulty:"})," Easy. There is always exactly one solution."]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"2-inverse-kinematics-ik",children:"2. Inverse Kinematics (IK)"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Question:"}),' "I want my hand at (x, y, z) with orientation (roll, pitch, yaw). What joint angles do I need?"']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Mechanism:"})," Solving non-linear equations (analytical or numerical)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Difficulty:"})," Hard.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Multiple Solutions:"})," You can touch your nose with your elbow up or down."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"No Solution:"})," The target is out of reach."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Singularities:"})," Configurations where the robot loses a degree of freedom (e.g., arm fully extended), causing mathematical instability and potentially dangerous infinite velocities."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"3-motion-planning",children:"3. Motion Planning"}),"\n",(0,o.jsx)(n.p,{children:"Finding a path from Pose A to Pose B while avoiding obstacles (including the robot's own body). Algorithms like RRT* (Rapidly-exploring Random Tree) sample the configuration space to find a collision-free trajectory."}),"\n",(0,o.jsx)(n.h3,{id:"\ufe0f-architecture-moveit-2",children:"\ud83d\udee0\ufe0f Architecture: MoveIt 2"}),"\n",(0,o.jsxs)(n.p,{children:["ROS 2 uses ",(0,o.jsx)(n.strong,{children:"MoveIt 2"})," as the standard motion planning framework."]}),"\n",(0,o.jsx)(n.mermaid,{value:"graph TD\n    A[User Goal / VLA Agent] --\x3e|MoveGroup Interface| B(MoveIt 2 Planner)\n    B --\x3e|Inverse Kinematics| C[IK Solver (KDL/Trac-IK)]\n    B --\x3e|Collision Checking| D[Planning Scene]\n    B --\x3e|Trajectory| E[Trajectory Execution]\n    E --\x3e|/joint_trajectory| F[Robot Controller]"}),"\n",(0,o.jsx)(n.h3,{id:"-implementation-basic-fkik-with-python",children:"\ud83d\udcbb Implementation: Basic FK/IK with Python"}),"\n",(0,o.jsx)(n.p,{children:"While MoveIt handles heavy lifting, understanding the math is crucial. We'll use a simple library to demonstrate."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\n# Conceptual IK solver for a 2-link planar arm\n# Link lengths\nL1 = 1.0\nL2 = 1.0\n\ndef inverse_kinematics(x, y):\n    """\n    Calculate joint angles (theta1, theta2) to reach (x, y).\n    Using Law of Cosines.\n    """\n    dist = np.sqrt(x**2 + y**2)\n    \n    # Check reachability\n    if dist > (L1 + L2):\n        print("Target out of reach!")\n        return None, None\n\n    # Law of Cosines for elbow angle (theta2)\n    # c2 = (x^2 + y^2 - l1^2 - l2^2) / (2 * l1 * l2)\n    cos_theta2 = (x**2 + y**2 - L1**2 - L2**2) / (2 * L1 * L2)\n    theta2 = np.arccos(cos_theta2) # Elbow down solution\n\n    # Angle to target\n    phi = np.arctan2(y, x)\n    # Angle offset for shoulder\n    # sin_theta2 / dist = sin_alpha / l2  ?? No, use Law of Cosines again or trig\n    # k1 = L1 + L2 * cos_theta2\n    # k2 = L2 * sin_theta2\n    # theta1 = phi - arctan2(k2, k1)\n    \n    # Simplified geometric approach for theta1\n    beta = np.arccos((L1**2 + dist**2 - L2**2) / (2 * L1 * dist))\n    theta1 = phi - beta\n\n    return np.degrees(theta1), np.degrees(theta2)\n\n# Test\ntarget_x, target_y = 1.414, 1.414 # Should be roughly 45 deg reach\nt1, t2 = inverse_kinematics(target_x, target_y)\nprint(f"To reach ({target_x}, {target_y}): Shoulder={t1:.2f}\xb0, Elbow={t2:.2f}\xb0")\n'})}),"\n",(0,o.jsx)(n.h3,{id:"\ufe0f-common-pitfalls-sim-vs-real",children:"\u26a0\ufe0f Common Pitfalls (Sim vs. Real)"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Simulation:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Ideal Geometry:"})," The robot model (URDF) matches the simulation perfectly."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"No Sag:"})," Joints are perfectly rigid."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Perfect Execution:"}),' If the planner says "move to X," the robot moves to X.']}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Reality:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Calibration Errors:"})," Real link lengths vary slightly due to manufacturing. The URDF might not match the physical robot, leading to IK errors (the hand isn't where the code thinks it is)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Backlash & Sag:"}),' Gearboxes have "play" (backlash). Heavy arms sag under gravity. A "perfect" IK solution might result in the end-effector being 2cm lower than expected.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Singularities:"})," Near singularities, motors might try to move at infinite speed. In sim, this might just look glitchy. In reality, this triggers over-current protection or damages hardware."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Self-Collision:"})," Cables and hoses aren't usually modeled in the collision scene. A valid plan might shear a cable in reality."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Fix:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Kinematic Calibration:"})," Use tools to refine the URDF based on physical measurements."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Singularity Avoidance:"}),' Use "Manipulability" metrics in IK solvers to avoid singular configurations.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Safety Margins:"}),' Pad collision volumes (make the robot look "fatter" to the planner) to account for cables and calibration errors.']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"-verification",children:"\ud83e\uddea Verification"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Visual Check (RViz):"}),' Use the "MotionPlanning" plugin in RViz. Drag the end-effector to a target. If the "ghost" robot follows, IK is working.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Plan & Execute:"}),' Click "Plan". Watch the visualized path. Ensure it doesn\'t pass through the robot body.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Tolerance Check:"}),' On the real robot, measure the actual end-effector position vs. the requested position. The difference is your "Kinematic Error".']}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"-chapter-summary",children:"\ud83d\udcdd Chapter Summary"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Kinematics"})," relates joint angles to end-effector position. ",(0,o.jsx)(n.strong,{children:"Forward (FK)"})," is simple (angles -> position); ",(0,o.jsx)(n.strong,{children:"Inverse (IK)"})," is complex (position -> angles)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Motion Planning"})," algorithms like RRT* find collision-free paths in high-dimensional spaces."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"MoveIt 2"})," is the standard ROS 2 framework for managing kinematics, planning, and collision checking."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Real-world challenges"})," include mechanical backlash, calibration discrepancies (URDF vs. Hardware), and unmodeled obstacles like cables."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"-conclusion",children:"\ud83d\udd1a Conclusion"}),"\n",(0,o.jsxs)(n.p,{children:["Mastering Inverse Kinematics and Motion Planning is the first step in giving a humanoid robot agency. Without it, a robot is just a statue. However, the mathematical precision of an IK solver often crashes against the messy reality of mechanical imperfections. As you move to the next chapter on Control, remember that ",(0,o.jsx)(n.em,{children:"planning"})," a motion is only half the battle; ",(0,o.jsx)(n.em,{children:"executing"})," it against gravity and friction is where the physics truly kicks in."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);